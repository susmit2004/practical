Spring Boot MVC Application 

Component 
Code 
HomeContrller.java package com.exampple.demo; 
import java.text.DateFormat; 
import java.util.Date; 
import java.util.Locale; 
import org.slf4j.Logger; 
import org.slf4j.LoggerFactory; 
import org.springframework.stereotype.Controller; 
import org.springframework.ui.Model; 
import 
org.springframework.web.bind.annotation.RequestMapping; 
import 
org.springframework.web.bind.annotation.RequestMethod; 
import org.springframework.validation.annotation.Validated; 
/** 
* Handles requests for the application home page. 
*/ 
@Controller 
public class HomeController { 
private static final Logger logger = 
LoggerFactory.getLogger(HomeController.class); 
/** 
* Simply selects the home view to render by returning its 
name. 
*/ 
@RequestMapping(value = "/", method = 
RequestMethod.GET) 
public String home(Locale locale, Model model) { 
logger.info("Welcome home! The client locale is {}.", 
locale); 
Date date = new Date(); 
  DateFormat dateFormat = 
DateFormat.getDateTimeInstance(DateFormat.LONG, 
DateFormat.LONG, locale); 
   
  String formattedDate = dateFormat.format(date); 
   
  model.addAttribute("serverTime", formattedDate ); 
   
  return "home"; 
 } 
  
  
} 
home.jsp <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %> 
<%@ page session="false" %> 
<html> 
<head> 
 <title>Home</title> 
</head> 
<body> 
<h1> 
 Hello world!   
</h1> 
 
<P>  The time on the server is ${serverTime}. </P> 
</body> 
</html> 
  
 
 
Output 
Springboot RESTFull API 
package com.example.demo; 
public class helloworldbean    
{   
public String message;   
//constructor of HelloWorldBean   
public helloworldbean(String message)   
{   
this.message=message;   
}   
//generating getters and setters   
public String getMessage()   
{   
return message;   
}   
public void setMessage(String message)    
{   
this.message = message;   
}   
@Override   
//generate toString   
public String toString()    
{   
return String.format ("HelloWorldBean 
[message=%s]", message);   
}   
}   
HelloworldController.java 
package com.example.demo; 
import 
org.springframework.web.bind.annotation.Ge
tMapping;   
import 
org.springframework.web.bind.annotation.Re
stController;   
//Controller   
@RestController   
public class HelloworldController    
{   
//using get method and hello-world as URI   
@GetMapping(path="/hello-world") 
public String helloWorld()   
{   
return "Hello World";   
}   
@GetMapping(path="/hello-world-bean")   
public helloworldbean helloWorldBean()   
{   
return new helloworldbean("Hello World"); 
//constructor of HelloWorldBean   
}   
}  
Restful3Application.java  
package com.example.demo; 
import org.springframework.boot.SpringApplication; 
import org.springframework.boot.autoconfigure.SpringBootApplication; 
@SpringBootApplication 
public class Restful3Application { 
public static void main(String[] args) { 
SpringApplication.run(Restful3Application.class, args); 
} 
} 
Restful3ApplicationTests.java  
package com.example.demo; 
import org.junit.jupiter.api.Test; 
import org.springframework.boot.test.context.SpringBootTest; 
@SpringBootTest 
class Restful3ApplicationTests { 
@Test 
void contextLoads() { 
} 
} 
Output 
.   
____          
_            
__ _ _ 
/\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \ 
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ 
\\/  ___)| |_)| | | | | || (_| |  ) ) ) ) 
'  |____| .__|_| |_|_| |_\__, | / / / / 
=========|_|==============|___/=/_/_/_/ 
:: Spring Boot ::                
(v2.4.2) 
2021-04-05 15:02:26.922  INFO 7280 --- [          
main] com.example.demo.Restful3Application     
: Starting Restful3Application using Java 
1.8.0_201 on DESKTOP-F5BFAHU with PID 7280 
(C:\Users\admin\jyoti\restful3\target\clas
ses started by admin in 
C:\Users\admin\jyoti\restful3) 
2021-04-05 15:02:26.926  INFO 7280 --- [          
main] com.example.demo.Restful3Application     
: No active profile set, falling back to 
default profiles: default 
2021-04-05 15:02:27.839  INFO 7280 --- [          
main] 
.s.d.r.c.RepositoryConfigurationDelegate : 
Bootstrapping Spring Data JPA repositories 
in DEFAULT mode. 
2021-04-05 15:02:27.852  INFO 7280 --- [          
main] 
.s.d.r.c.RepositoryConfigurationDelegate : 
Finished Spring Data repository scanning 
in 5 ms. Found 0 JPA repository 
interfaces. 
2021-04-05 15:02:28.283  INFO 7280 --- [          
main] 
o.s.b.w.embedded.tomcat.TomcatWebServer  : 
Tomcat initialized with port(s): 8080 
(http) 
2021-04-05 15:02:28.291  INFO 7280 --- [          
main] 
o.apache.catalina.core.StandardService   
Starting service [Tomcat] 
2021-04-05 15:02:28.291  INFO 7280 --- [          
main] 
: 
org.apache.catalina.core.StandardEngine  : 
Starting Servlet engine: [Apache 
Tomcat/9.0.41] 
2021-04-05 15:02:28.378  INFO 7280 --- [          
main] o.a.c.c.C.[Tomcat].[localhost].[/]       
: Initializing Spring embedded 
WebApplicationContext 
2021-04-05 15:02:28.378  INFO 7280 --- [          
main] 
w.s.c.ServletWebServerApplicationContext : 
Root WebApplicationContext: initialization 
completed in 1409 ms 
2021-04-05 15:02:28.568  INFO 7280 --- [          
main] com.zaxxer.hikari.HikariDataSource       
: HikariPool-1 - Starting... 
2021-04-05 15:02:28.700  INFO 7280 --- [          
main] com.zaxxer.hikari.HikariDataSource       
: HikariPool-1 - Start completed. 
2021-04-05 15:02:28.752  INFO 7280 --- [          
main] 
o.hibernate.jpa.internal.util.LogHelper  : 
HHH000204: Processing PersistenceUnitInfo 
[name: default] 
2021-04-05 15:02:28.811  INFO 7280 --- [          
main] org.hibernate.Version                    
: HHH000412: Hibernate ORM core version 
5.4.27.Final 
2021-04-05 15:02:28.989  INFO 7280 --- [          
main] 
o.hibernate.annotations.common.Version   
: 
HCANN000001: Hibernate Commons Annotations 
{5.1.2.Final} 
2021-04-05 15:02:29.157  INFO 7280 --- [          
main] org.hibernate.dialect.Dialect            
: HHH000400: Using dialect: 
org.hibernate.dialect.H2Dialect 
2021-04-05 15:02:29.319  INFO 7280 --- [          
main] o.h.e.t.j.p.i.JtaPlatformInitiator       
: HHH000490: Using JtaPlatform 
implementation: 
[org.hibernate.engine.transaction.jta.plat
form.internal.NoJtaPlatform] 
2021-04-05 15:02:29.332  INFO 7280 --- [          
main] 
j.LocalContainerEntityManagerFactoryBean : 
Initialized JPA EntityManagerFactory for 
persistence unit 'default' 
2021-04-05 15:02:29.423  WARN 7280 --- [          
main] 
JpaBaseConfiguration$JpaWebConfiguration : 
spring.jpa.open-in-view is enabled by 
default. Therefore, database queries may 
be performed during view rendering. 
Explicitly configure 
spring.jpa.open-in-view to disable this 
warning 
2021-04-05 15:02:29.574  INFO 7280 --- [          
main] 
o.s.s.concurrent.ThreadPoolTaskExecutor  : 
Initializing ExecutorService 
'applicationTaskExecutor' 
2021-04-05 15:02:29.802  INFO 7280 --- [          
main] 
o.s.b.w.embedded.tomcat.TomcatWebServer  : 
Tomcat started on port(s): 8080 (http) 
with context path '' 
2021-04-05 15:02:29.810  INFO 7280 --- [          
main] com.example.demo.Restful3Application     
: Started Restful3Application in 3.409 
seconds (JVM running for 4.375) 
we will see the steps to set up a Spring Boot application with PostgreSQL. We will 
have a simple CRUD operation in Postgres Database by exposing the application via 
Rest API. We will use POSTMAN to test the application. 
Setting up Postgres Server 
● Download the Postgres server from the link: 
https://www.postgresql.org/download/ 
● Run the installer. It will also ask the password for the superuser: postgres 
● Click on pgAdmin4.exe located inside the PostgreSQL folder inside Program 
Files. 
Setting up Spring Boot Application 
Prerequisite: 
Have JDK 1.8 installed 
● Download a sample Spring Boot project from https://start.spring.io/ 
● Update the pom.xml as below: 
<?xml version="1.0" encoding="UTF-8"?> 
1 
2 
<project xmlns="http://maven.apache.org/POM/4.0.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
3 
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/xsd/maven-4.0.0.xsd"> 
4 
<modelVersion>4.0.0</modelVersion> 
5 
<parent> 
6 
<groupId>org.springframework.boot</groupId> 
7 
<artifactId>spring-boot-starter-parent</artifactId> 
8 
<version>2.1.1.RELEASE</version> 
9 
<relativePath /> <!-- lookup parent from repository --> 
10 
</parent> 
11 
<groupId>com.sample</groupId> 
12 
<artifactId>postgress</artifactId> 
13 
<version>0.0.1-SNAPSHOT</version> 
14 
<name>postgress</name> 
15 
<description>Demo project for Spring Boot</description> 
16 
  
17 
<properties> 
18 
<java.version>1.8</java.version> 
19 
</properties> 
20 
  
21 
<dependencies> 
22 
<dependency> 
23 
<groupId>org.springframework.boot</groupId> 
24 
<artifactId>spring-boot-starter</artifactId> 
25 
</dependency> 
26 
<dependency> 
27 
<groupId>org.springframework.boot</groupId> 
28 
<artifactId>spring-boot-starter-web</artifactId> 
29 
</dependency> 
30 
<dependency> 
31 
<groupId>org.springframework.boot</groupId> 
32 
<artifactId>spring-boot-starter-jdbc</artifactId> 
33 
</dependency> 
34 
<dependency> 
35 
<groupId>org.postgresql</groupId> 
36 
<artifactId>postgresql</artifactId> 
37 
<scope>runtime</scope> 
</dependency> 
38 
39 
<dependency> 
40 
<groupId>org.springframework.boot</groupId> 
41 
<artifactId>spring-boot-starter-test</artifactId> 
42 
<scope>test</scope> 
43 
</dependency> 
44 
</dependencies> 
45 
46 
<build> 
47 
<plugins> 
48 
<plugin> 
49 
<groupId>org.springframework.boot</groupId> 
50 
<artifactId>spring-boot-maven-plugin</artifactId> 
51 
</plugin> 
52 
</plugins> 
53 
</build> 
54 
55 
</project> 
spring-boot-starter-jdbc artifact will give all the spring jdbc related jars 
org.postgresql.postgresql will have the dependency of postgres jdbc driver in 
runtime. 
● Create a schema.sql in resource folder. An employee table will be created in 
server startup. This can be ignored if you don't want the initial database to be 
configured during server start. Generally, for building a production-ready 
application, this step can be ignored as tables will be created with scrip 
directly in the DB. 
CREATE TABLE employee 
1 
2 
( 
3 
employeeName varchar(100) NOT NULL, 
4 
employeeId varchar(11) NOT NULL , 
employeeAddress varchar(100) DEFAULT NULL, 
5 
6 
employeeEmail varchar(100) DEFAULT NULL, 
7 
PRIMARY KEY (employeeId) 
8 
); 
● Create data.sql in resource folder for loading the first set of employee during 
startup. Can be skipped otherwise: 
insert into employee(employeeId, employeeName , 
employeeAddress,employeeEmail) values('1','Jack','USA','jack@gmail.com'); 
● Changes in application.properties to configure the data source with URL, 
username, and password of the Postgres DB. 5432 is the default port of 
Postgres. Hibernate will automatically pick up the postgressSQLDialect. 
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect 
1 
2 
spring.jpa.hibernate.ddl-auto=none 
3 
spring.jpa.hibernate.show-sql=true 
4 
spring.datasource.url=jdbc:postgresql://localhost:5432/postgres 
5 
spring.datasource.username=postgres 
6 
spring.datasource.password=admin 
7 
8 
9 
spring.datasource.initialization-mode=always 
10 
spring.datasource.initialize=true 
11 
spring.datasource.schema=classpath:/schema.sql 
12 
spring.datasource.continue-on-error=true 
spring.jpa.hibernate.ddl-auto will turn off the hibernate auto-creation of the 
tables from the entity objects. Generally, Hibernate runs it if there is an Entity 
defined. But we will be using a native SQL query with JdbcTemplate, hence, we can 
turn this off as we will not be creating an Entity. 
spring.datasource.initialization-mode is marked as always as we want 
initialization of the database to happen on every startup. This is optional and made 
for this sample purpose. 
spring.datasource.initialize=true will mark the initialization to be true. 
spring.datasource.continue-on-error=true will continue application startup in 
spite of any errors in data initialization. 
spring.datasource.schema is the schema path that needs to be initialized. 
spring.datasource.url URL of the Postgres DB. It can be a remote DB as well. 
spring.datasource.username username for the database. 
spring.datasource.password password for the database. 
● Create a dao interface and dao implementation. 
package com.sample.postgress.dao; 
1 
2 
3 
import java.util.List; 
4 
5 
import com.sample.postgress.entity.Employee; 
6 
7 
public interface EmployeeDao { 
8 
9 
List<Employee> findAll(); 
10 
11 
void insertEmployee(Employee emp); 
12 
13 
void updateEmployee(Employee emp); 
14 
15 
void executeUpdateEmployee(Employee emp); 
16 
17 
public void deleteEmployee(Employee emp); 
18 
} 
1 
package com.sample.postgress.dao; 
2 
3 
import java.sql.PreparedStatement; 
4 
import java.sql.SQLException; 
5 
import java.util.HashMap; 
6 
import java.util.List; 
7 
import java.util.Map; 
8 
  
9 
import org.springframework.dao.DataAccessException; 
10 
import org.springframework.jdbc.core.PreparedStatementCallback; 
11 
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource; 
12 
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate; 
13 
import org.springframework.jdbc.core.namedparam.SqlParameterSource; 
14 
import org.springframework.jdbc.support.GeneratedKeyHolder; 
15 
import org.springframework.jdbc.support.KeyHolder; 
16 
import org.springframework.stereotype.Repository; 
17 
  
18 
import com.sample.postgress.entity.Employee; 
19 
import com.sample.postgress.mapper.EmployeeRowMapper; 
20 
@Repository 
21 
public class EmployeeDaoImpl implements EmployeeDao{ 
22 
  
23 
public EmployeeDaoImpl(NamedParameterJdbcTemplate template) {   
24 
        this.template = template;   
25 
}   
26 
NamedParameterJdbcTemplate template;   
27 
  
28 
@Override 
29 
public List<Employee> findAll() { 
30 
return template.query("select * from employee", new EmployeeRowMapper()); 
31 
} 
32 
@Override 
33 
public void insertEmployee(Employee emp) { 
34 
 final String sql = "insert into employee(employeeId, employeeName , 
employeeAddress,employeeEmail) 
values(:employeeId,:employeeName,:employeeEmail,:employeeAddress)"; 
35 
  
36 
        KeyHolder holder = new GeneratedKeyHolder(); 
37 
        SqlParameterSource param = new MapSqlParameterSource() 
38 
.addValue("employeeId", emp.getEmployeeId()) 
39 
.addValue("employeeName", emp.getEmployeeName()) 
40 
.addValue("employeeEmail", emp.getEmployeeEmail()) 
41 
.addValue("employeeAddress", emp.getEmployeeAddress()); 
42 
        template.update(sql,param, holder); 
43 
  
44 
} 
45 
  
46 
@Override 
47 
public void updateEmployee(Employee emp) { 
48 
 final String sql = "update employee set employeeName=:employeeName, 
employeeAddress=:employeeAddress, employeeEmail=:employeeEmail where 
employeeId=:employeeId"; 
49 
  
50 
        KeyHolder holder = new GeneratedKeyHolder(); 
51 
        SqlParameterSource param = new MapSqlParameterSource() 
52 
.addValue("employeeId", emp.getEmployeeId()) 
53 
.addValue("employeeName", emp.getEmployeeName()) 
54 
.addValue("employeeEmail", emp.getEmployeeEmail()) 
55 
.addValue("employeeAddress", emp.getEmployeeAddress()); 
56 
        template.update(sql,param, holder); 
57 
  
58 
} 
59 
  
60 
@Override 
61 
public void executeUpdateEmployee(Employee emp) { 
62 
 final String sql = "update employee set employeeName=:employeeName, 
employeeAddress=:employeeAddress, employeeEmail=:employeeEmail where 
employeeId=:employeeId"; 
63 
  
64 
  
65 
 Map<String,Object> map=new HashMap<String,Object>();   
66 
 map.put("employeeId", emp.getEmployeeId()); 
67 
 map.put("employeeName", emp.getEmployeeName()); 
68 
 map.put("employeeEmail", emp.getEmployeeEmail()); 
69 
 map.put("employeeAddress", emp.getEmployeeAddress()); 
70 
  
71 
 template.execute(sql,map,new PreparedStatementCallback<Object>() {   
72 
    @Override   
73 
    public Object doInPreparedStatement(PreparedStatement ps)   
74 
            throws SQLException, DataAccessException {   
75 
        return ps.executeUpdate();   
76 
    }   
77 
});   
78 
  
79 
  
80 
} 
81 
  
82 
@Override 
83 
public void deleteEmployee(Employee emp) { 
84 
 final String sql = "delete from employee where employeeId=:employeeId"; 
85 
  
86 
  
87 
 Map<String,Object> map=new HashMap<String,Object>();   
88 
map.put("employeeId", emp.getEmployeeId()); 
89 
90 
template.execute(sql,map,new PreparedStatementCallback<Object>() {   
91 
@Override   
92 
public Object doInPreparedStatement(PreparedStatement ps)   
93 
throws SQLException, DataAccessException {   
94 
return ps.executeUpdate();   
95 
}   
96 
});   
97 
98 
99 
} 
100 
101 
} 
● findAll() retrieves all the employee and then map the resultset to a Employee 
Object using RowMapper described below . 
● insertEmployee() will insert an employee using template.update(sql,param, 
holder) where param is the SqlParameterSource, which will map the values 
dynamically in the query marked with a colon. GeneratedKeyHolder will 
return an auto-generated value when  data is inserted. 
● executeUpdateEmployee() will update the employee using template.execute 
template.execute(sql,map,new PreparedStatementCallback<Object>() {   
1 
2 
@Override   
3 
public Object doInPreparedStatement(PreparedStatement ps)   
4 
throws SQLException, DataAccessException {   
5 
return ps.executeUpdate();   
6 
}   
7 
});  
● EmployeeRowMapper to map the result set retrieved from the select query 
with the POJO. 
1 
package com.sample.postgress.mapper; 
2 
  
3 
import java.sql.ResultSet; 
4 
import java.sql.SQLException; 
5 
  
6 
import org.springframework.jdbc.core.RowMapper; 
7 
  
8 
import com.sample.postgress.entity.Employee; 
9 
  
10 
public class EmployeeRowMapper implements RowMapper<Employee> { 
11 
  
12 
@Override 
13 
public Employee mapRow(ResultSet rs, int arg1) throws SQLException { 
14 
Employee emp = new Employee(); 
15 
emp.setEmployeeId(rs.getString("employeeId")); 
16 
emp.setEmployeeName(rs.getString("employeeName")); 
17 
emp.setEmployeeEmail(rs.getString("employeeEmail")); 
18 
  
19 
        return emp; 
20 
} 
21 
  
22 
  
23 
} 
● You can create a controller and a service class as follows: 
1 
package com.sample.postgress.controller; 
2 
  
3 
import java.util.List; 
4 
  
5 
import javax.annotation.Resource; 
6 
  
7 
import org.springframework.web.bind.annotation.DeleteMapping; 
8 
import org.springframework.web.bind.annotation.GetMapping; 
9 
import org.springframework.web.bind.annotation.PostMapping; 
10 
import org.springframework.web.bind.annotation.PutMapping; 
11 
import org.springframework.web.bind.annotation.RequestBody; 
12 
import org.springframework.web.bind.annotation.RequestMapping; 
13 
import org.springframework.web.bind.annotation.RestController; 
14 
  
15 
import com.sample.postgress.entity.Employee; 
16 
import com.sample.postgress.service.EmployeeService; 
17 
  
18 
@RestController 
19 
@RequestMapping("/postgressApp") 
20 
public class ApplicationController { 
21 
  
22 
@Resource  
23 
EmployeeService employeeService; 
24 
  
25 
@GetMapping(value = "/employeeList") 
26 
public List<Employee> getEmployees() { 
27 
return employeeService.findAll(); 
28 
  
29 
} 
30 
  
31 
@PostMapping(value = "/createEmp") 
32 
public void createEmployee(@RequestBody Employee emp) { 
33 
 employeeService.insertEmployee(emp); 
34 
35 
} 
36 
@PutMapping(value = "/updateEmp") 
37 
public void updateEmployee(@RequestBody Employee emp) { 
38 
employeeService.updateEmployee(emp); 
39 
40 
} 
41 
@PutMapping(value = "/executeUpdateEmp") 
42 
public void executeUpdateEmployee(@RequestBody Employee emp) { 
43 
employeeService.executeUpdateEmployee(emp); 
44 
45 
} 
46 
47 
@DeleteMapping(value = "/deleteEmpById") 
48 
public void deleteEmployee(@RequestBody Employee emp) { 
49 
employeeService.deleteEmployee(emp); 
50 
51 
} 
52 
53 
54 
} 
Now, let's use POSTMAN to validate the changes: 
Test 1: Get the list of employees 
http://localhost:8080/postgressApp/employeeList 
Test 2: Create An employee 
http://localhost:8080/postgressApp/createEmp 
We see an entry got inserted with JONES. 
Test 3: Update an Employee 
http://localhost:8080/postgressApp/executeUpdateEmp 
Test 4: Delete Employee 
http://localhost:8080/postgressApp/deleteEmpById 
Conclusion 
We have learned how to set up a Spring Boot application with Postgres and how to 
do a CRUD operation. 



Spring Boot MVC Application 
Component 
User.java 
Code 
package com.m1.m2; 
public class User { 
private String userName; 
public String getUserName() { 
return userName; 
} 
public void setUserName(String userName) { 
this.userName = userName; 
} 
} 
HomeContrller.java package com.m1.m2; 
import java.text.DateFormat; 
import java.util.Date; 
import java.util.Locale; 
import org.slf4j.Logger; 
import org.slf4j.LoggerFactory; 
import org.springframework.stereotype.Controller; 
import org.springframework.ui.Model; 
import 
org.springframework.web.bind.annotation.RequestMapping; 
import 
org.springframework.web.bind.annotation.RequestMethod; 
import org.springframework.validation.annotation.Validated; 
/** 
* Handles requests for the application home page. 
*/ 
@Controller 
public class HomeController { 
private static final Logger logger = 
LoggerFactory.getLogger(HomeController.class); 
/** 
* Simply selects the home view to render by returning its 
name. 
*/ 
@RequestMapping(value = "/", method = 
RequestMethod.GET) 
public String home(Locale locale, Model model) { 
logger.info("Welcome home! The client locale is {}.", 
locale); 
Date date = new Date(); 
DateFormat dateFormat = 
DateFormat.getDateTimeInstance(DateFormat.LONG, 
DateFormat.LONG, locale); 
String formattedDate = dateFormat.format(date); 
model.addAttribute("serverTime", formattedDate ); 
return "home"; 
} 
@RequestMapping(value = "/user", method = 
RequestMethod.POST) 
public String user(@Validated User user, Model model) { 
System.out.println("User Page Requested"); 
model.addAttribute("userName", 
user.getUserName()); 
return "user"; 
} 
} 
Home.jsp 
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %> 
<%@ page session="false" %> 
<html> 
<head> 
<title>Home</title> 
</head> 
<body> 
<h1> 
Hello world!   
</h1> 
 
<P>  The time on the server is ${serverTime}. </P> 
<form action="user" method="post"> 
  <input type="text" name="userName"><br> <input 
   type="submit" value="Login"> 
 </form> 
</body> 
</html> 
User.jsp <%@ page language="java" contentType="text/html; 
charset=UTF-8" 
    pageEncoding="UTF-8"%> 
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 
Transitional//EN" "https://www.w3.org/TR/html4/loose.dtd"> 
<html> 
<head> 
<meta http-equiv="Content-Type" content="text/html; 
charset=UTF-8"> 
<title>User Home Page</title> 
</head> 
<body> 
<h3>Hi ${userName}</h3> 
</body> 
</html> 
  
 
 
 
Spring Spring Boot 
Spring Framework is a 
widely used Java EE 
framework for building 
applications. 
Spring Boot Framework is widely used to 
develop REST APIs. 
It aims to simplify Java EE 
development that makes 
developers more productive. 
It aims to shorten the code length and provide 
the easiest way to develop Web Applications. 
The primary feature of the 
Spring Framework 
is dependency injection. 
The primary feature of Spring Boot 
is Autoconfiguration. It automatically 
configures the classes based on the 
requirement. 
It helps to make things simpler 
by allowing us to 
develop loosely 
coupled applications. 
It helps to create a stand-alone application 
with less configuration. 
The developer writes a lot of 
code (boilerplate code) to do 
the minimal task. 
It reduces boilerplate code. 
To test the Spring project, we 
need to set up the sever 
explicitly. 
Spring Boot offers embedded server such 
as Jetty and Tomcat, etc. 
It does not provide support for 
an in-memory database. 
It offers several plugins for working with an 
embedded and in-memory database such 
as H2. 
Developers manually define 
dependencies for the Spring 
project in pom.xml. 
Spring Boot comes with the concept 
of starter in pom.xml file that internally takes 
care of downloading the 
dependencies JARs based on Spring Boot 
Requirement. 
 
 
Spring Boot Spring MVC 
Spring Boot is a module of Spring for 
packaging the Spring-based application 
with sensible defaults. 
Spring MVC is a model view 
controller-based web framework 
under the Spring framework. 
It provides default configurations to 
build Spring-powered framework. 
There is no need to build configuration 
manually. 
There is no requirement for a deployment 
descriptor. 
It avoids boilerplate code and wraps 
dependencies together in a single unit. 
It reduces development time and increases 
productivity. 
It provides ready to use features 
for building a web application. 
It requires build configuration 
manually. 
A Deployment descriptor 
is required. 
It specifies each dependency 
separately. 
It takes more time to achieve the 
same. 
Introduction to RESTful Web Services 
Advantages of RESTful web services 
o RESTful web services are platform-independent. 
o It can be written in any programming language and can be executed on any 
platform. 
o It provides different data format like JSON, text, HTML, and XML. 
o It is fast in comparison to SOAP because there is no strict specification like 
SOAP. 
o These are reusable. 
o They are language neutral. 
Spring Boot provides a very good support to building RESTful Web Services for 
enterprise applications 
REST stands for REpresentational State Transfer. It is developed by Roy 
Thomas Fielding, who also developed HTTP. The main goal of RESTful web 
services is to make web services more effective. RESTful web services try to 
define services using the different concepts that are already present in HTTP. REST 
is an architectural approach, not a protocol. 
• RESTful web services are loosely coupled, lightweight web services that 
are particularly well suited for creating APIs for clients spread out across the 
internet. Representational State Transfer (REST) is an architectural style of 
client-server 
application 
centered 
the transfer of representations of resources through 
around 
requests 
and 
responses. In the REST architectural style, data and functionality are 
considered resources and are accessed using Uniform Resource Identifiers 
(URIs), typically links on the Web. The resources are represented by 
documents and are acted upon by using a set of simple, well-defined 
operations. 
• For example, a REST resource might be the current weather conditions for a 
city. The representation of that resource might be an XML document, an 
image file, or an HTML page. A client might retrieve a particular 
representation, modify the resource by updating its data, or delete the 
resource entirely. 
• The REST architectural style is designed to use a stateless communication 
protocol, typically HTTP. In the REST architecture style, clients and servers 
exchange representations of resources by using a standardized interface and 
protocol. 
It does not define the standard message exchange format. We can build REST 
services with both XML and JSON. JSON is more popular format with REST. 
The key abstraction is a resource in REST. A resource can be anything. It can be 
accessed through a Uniform Resource Identifier (URI). For example: 
The resource has representations like XML, HTML, and JSON. The current state 
capture by representational resource. When we request a resource, we provide the 
representation of the resource. The important methods of HTTP are: 
o GET: It reads a resource. 
o PUT: It updates an existing resource. 
o POST: It creates a new resource. 
o DELETE: It deletes the resource. 
For example, if we want to perform the following actions in the social media 
application, we get the corresponding results. 
POST /users: It creates a user. 
GET /users/{id}: It retrieves the detail of a user. 
GET /users: It retrieves the detail of all users. 
DELETE /users: It deletes all users. 
DELETE /users/{id}: It deletes a user. 
GET /users/{id}/posts/post_id: It retrieve the detail of a specific post. 
POST / users/{id}/ posts: It creates a post of the user. 
Further, we will implement these URI in our project. 
HTTP also defines the following standard status code: 
o 404: RESOURCE NOT FOUND 
o 200: SUCCESS 
o 201: CREATED 
o 401: UNAUTHORIZED 
o 500: SERVER ERROR 
RESTful Service Constraints 
o There must be a service producer and service consumer. 
o The service is stateless. 
o The service result must be cacheable. 
o The interface is uniform and exposing resources. 
o The service should assume a layered architecture. 
 
 Setup
 
Spring
 
Boot
 
Project
 
Create the project: 
Go to Spring Initializr. 
Fill in the project details: 
Project: Maven 
Language: Java 
Spring Boot version: (Latest stable version, e.g., 3.1.x) 
Dependencies: 
Spring Web 
Spring Data JPA 
PostgreSQL Driver 
Click Generate to download the project. 
Unzip and Import: 
Unzip the project. 
Import it into your IDE (e.g., IntelliJ IDEA or Eclipse) as a Maven project. 
2.
 
Configure
 application.properties 
Configure the connection to the PostgreSQL database in 
src/main/resources/application.properties (or application.yml if using 
YAML): 
properties 
Copy code 
spring.datasource.url=jdbc:postgresql://localhost:5432/your_database 
spring.datasource.username=your_username 
spring.datasource.password=your_password 
spring.datasource.driver-class-name=org.postgresql.Driver 
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect 
spring.jpa.hibernate.ddl-auto=update 
3.
 
Create
 
PostgreSQL
 
Database
 
Before running the application, make sure PostgreSQL is installed and running. Then: 
Create a new database 
Update the username and password in application.properties to match your PostgreSQL 
setup. 
4.
 
Define
 
an
 
Entity
 
Create a simple entity class in the src/main/java/com/example/demo package (or 
appropriate package). 
java 
Copy code 
package com.example.demo.entity; 
import jakarta.persistence.Entity;import 
jakarta.persistence.GeneratedValue;import 
jakarta.persistence.GenerationType;import jakarta.persistence.Id; 
@Entitypublic class User { 
@Id 
@GeneratedValue(strategy = GenerationType.IDENTITY) 
private Long id; 
private String name; 
private String email; 
// Getters and Setters 
public Long getId() { 
return id; 
} 
public void setId(Long id) { 
this.id = id; 
} 
public String getName() { 
return name; 
} 
public void setName(String name) { 
this.name = name; 
} 
public String getEmail() { 
return email; 
} 
public void setEmail(String email) { 
this.email = email; 
} 
} 
5.
 
Create
 
a
 
Repository
 
Create a JPA repository interface for CRUD operations. 
java 
Copy code 
package com.example.demo.repository; 
import com.example.demo.entity.User;import 
org.springframework.data.jpa.repository.JpaRepository; 
public interface UserRepository extends JpaRepository<User, Long> { 
} 
6.
 
Create
 
a
 
REST
 
Controller
 
Create a REST controller to expose CRUD operations. 
java 
Copy code 
package com.example.demo.controller; 
import com.example.demo.entity.User;import 
com.example.demo.repository.UserRepository;import 
org.springframework.beans.factory.annotation.Autowired;import 
org.springframework.web.bind.annotation.*; 
import java.util.List; 
@RestController@RequestMapping("/users")public class UserController { 
@Autowired 
private UserRepository userRepository; 
@GetMapping 
public List<User> getAllUsers() { 
return userRepository.findAll(); 
} 
@PostMapping 
public User createUser(@RequestBody User user) { 
return userRepository.save(user); 
} 
} 
7.
 
Run
 
the
 
Application
 
Run the application:In the terminal: 
bash 
Copy code 
mvn spring-boot:run 
Or in your IDE by running the main method in the DemoApplication class. 
8.
 
Test
 
the
 
Application
 
Use a tool like Postman or curl to test the endpoints. 
GET all users: 
bash 
Copy code 
curl -X GET http://localhost:8080/users 
POST a new user: 
bash 
Copy code 
curl -X POST -H "Content-Type: application/json" -d 
'{"name":"John Doe", "email":"john.doe@example.com"}' 
http://localhost:8080/users 



PreparedStatementCallback interface 
It processes the input parameters and output results. In such case, you don't need to 
care about single and double quotes. 
Method of PreparedStatementCallback interface 
It has only one method doInPreparedStatement. Syntax of the method is given below: 
public T doInPreparedStatement(PreparedStatement ps)throws SQLException, DataAcces
sException   
ResultSetExtractor is an interface that is used to fetch the records from 
the database. It’s a callback interface that is used by JDBC Template’s 
query() method where we need to pass the instance of ResultSetExtractor 
in order to fetch the data. 
Syntax of query() method of ResultSetExtractor: 
public T query(String sqlQuery, ResultSetExtractor<T> 
resultSetExtractor) 
In order to fetch the data using ResultSetExtractor, we need to implement 
the ResultSetExtractor interface and provide the definition for its method. It 
has only one method. i.e., extractData() which takes an instance of 
ResultSet as an argument and returns the list. 
Syntax of extractData() method: 
public T extractData(ResultSet resultSet) throws SQL Exception, 
DataAccessException 
In Spring, the RowMapper interface is used to fetch the records from the 
database using the query() method of the JdbcTemplate class.  
Syntax for query() method of JdbcTemplate class: 
public T query(String sqlQuery, RowMapper<T> rowMapper) 
RowMapper is a callback interface that is called for each row and maps the 
row of relations with the instances to the model(user-defined) class. Unlike 
ResultSetExtractor the RowMapper iterates the ResultSet internally and 
adds the extracted data into a collection, And we do not need to write the 
code for collections as we do in ResultSetExtractor. It has only one method 
mapRow() which takes two arguments ResultSet and rowNumber 
respectively. In order to use RowMapper, we need to implement this 
interface and provide the definition for mapRow() method.  
Syntax for rowMapper() method:  
public T mapRow(ResultSet resultSet, int rowNumber)throws 
SQLException 
Spring JDBC 
1. Write a program to insert, update and delete records from the given table.  
2. Write a program to demonstrate PreparedStatement in Spring JdbcTemplate.  
3. Write a program in Spring JDBC to demonstrate ResultSetExtractor Interface. 
4. Write a program to demonstrate RowMapper interface to fetch the records from the 
database 
Steps to Create Spring Legacy Project 
Step 1 :  Creating Spring Legacy Project. 
1.1 : Open Eclipse. Go To File > New > Other. 
1.2: Search for ‘spring’ and Select ‘Spring Legacy Project’. Then Click on Next. 
1.3 : Enter Project Name of your wish, and click on Finish. 
1.4 : If asked to create module-info.java file, select ‘Don’t Create’. 
1.5 : Finally if you are asked to Open Java Perspective, just choose NO.  
This creates your AspectJ project. 
step 2 : Adding the Spring Libraries. 
2.1 : Right click on your Newly created AspectJ project, Choose Build Path > Configure 
Build Path. 
2.2 On Java Build Path wizard, Choose Classpath and then select Add External JARs. 
2.3 : Choose all the Spring Libraries you’ve downloaded, and click on OPEN. This will add 
all libraries to Classpath. 
2.4 Finally click on Apply & Close, now you are ready to work with Aspects in Spring. 
Problem Statement 9.1 : Write a program to insert, update and delete records from the given 
table.  
Solution: 
How to generate getter and setter methods 
Right click on file-> source-> Generate getters and setters methods. 
Filename-Movie1.java 
public class Movie1 { 
int mid; 
String title; 
String actor; 
public Movie1(int mid, String title, String actor) { 
super(); 
this.mid = mid; 
this.title = title; 
this.actor = actor; 
} 
public Movie1() { 
super(); 
} 
public int getMid() { 
return mid; 
} 
 public void setMid(int mid) { 
  this.mid = mid; 
 } 
 
 
 public String getTitle() { 
  return title; 
 } 
 public void setTitle(String title) { 
  this.title = title; 
 } 
 public String getActor() { 
  return actor; 
 } 
 public void setActor(String actor) { 
  this.actor = actor; 
 } 
 
  
 } 
 
Filename-MovieDAO.java 
import org.springframework.jdbc.core.JdbcTemplate; 
 
public class MovieDAO { 
 JdbcTemplate jdbcTemplate; 
 
 public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { 
  this.jdbcTemplate = jdbcTemplate; 
 } 
 public int insMovie(Movie1 m1) 
 {   
  String insSql="insert into movies 
values("+m1.getMid()+",'"+m1.getTitle()+"','"+m1.getActor()+"')"; 
 
 return jdbcTemplate.update(insSql); 
 } 
 
 public int updateMovie(Movie1 m1){   
     String query="update movies set 
title='"+m1.getTitle()+"',actor='"+m1.getActor()+"' where mid='"+m1.getMid()+"' ";   
     return jdbcTemplate.update(query);   
 }   
 
 public int deleteMovie(Movie1 m1){   
     String query="delete from movies where mid='"+m1.getMid()+"' ";   
     return jdbcTemplate.update(query);   
 } } 
 
 
Create Xml file 
Create Xml file 
Filename-appctx.xml 
<?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">   
<property name="driverClassName" value="org.postgresql.Driver" />   
<property name="url" value="jdbc:postgresql://localhost:5434/postgres" />   
<property name="username" value="postgres" />   
<property name="password" value="ravita123" />   
</bean>   
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">   
<property name="dataSource" ref="ds"></property>   
</bean>   
<bean id="mymovie" class="MovieDAO">   
<property name="jdbcTemplate" ref="jdbcTemplate"></property>   
</bean>  
</beans> 
Create Main java File 
Filename-MovieTest.java  
import org.springframework.context.ApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
public class MovieTest { 
private static ApplicationContext appCon; 
public static void main(String[] args) { 
// TODO Auto-generated method stub 
appCon = new ClassPathXmlApplicationContext("appctx.xml"); 
MovieDAO m1 = (MovieDAO) appCon.getBean("mymovie"); 
// insert query 
Movie1 t1 = new Movie1(4, "17 Again", "Zac"); 
System.out.println(m1.insMovie(t1)); 
Movie1 t = new Movie1(5, "Interstellar", "Christopher"); 
System.out.println(m1.insMovie(t)); 
// update query 
int status = m1.updateMovie(new Movie1(1, "18 Again", "Zac")); 
System.out.println(status); 
// delete 
Movie1 t2=new Movie1();  
t2.setMid(3); 
int s=m1.deleteMovie(t2); 
System.out.println(s);   
} } 
First we insert 3 records 
// insert query 
Movie1 t1 = new Movie1(1, "17 Again", "Zac"); 
System.out.println(m1.insMovie(t1)); 
Movie1 t2 = new Movie1(2, "23 Again", "Zac"); 
System.out.println(m1.insMovie(t)); 
Movie1 t3 = new Movie1(3, "Interstellar", "Christopher"); 
System.out.println(m1.insMovie(t)); 
Update: 
We update row 1 
Delete: 
We deleted row no 3 So, After deleted row 
Database: 
Create Movies Table : 
CREATE TABLE movies ( 
mid int, 
title varchar(50), 
actor varchar(50), 
PRIMARY KEY (mid) 
); 
Problem Statement 9.2 : Write a program to demonstrate PreparedStatement in Spring 
JdbcTemplate.  
Solution : 
Filename- Movie1.java 
 
public class Movie1 { 
 int mid; 
 String title; 
 String actor; 
 public Movie1(int mid, String title, String actor) { 
  super(); 
  this.mid = mid; 
  this.title = title; 
  this.actor = actor; 
 } 
 public Movie1() { 
  super(); 
 } 
 public int getMid() { 
  return mid; 
 } 
 public void setMid(int mid) { 
  this.mid = mid; 
 } 
 public String getTitle() { 
  return title; 
 } 
 public void setTitle(String title) { 
  this.title = title; 
 } 
 public String getActor() { 
  return actor; 
 } 
 public void setActor(String actor) { 
  this.actor = actor; 
 } 
 
 
} 
 
 
Filename- MovieDAO1.java 
import java.sql.PreparedStatement;   
import java.sql.SQLException;   
   
import org.springframework.dao.DataAccessException;   
import org.springframework.jdbc.core.JdbcTemplate;   
 
 
import org.springframework.jdbc.core.PreparedStatementCallback;   
 
public class MovieDAO1 { 
 JdbcTemplate jdbcTemplate; 
 
 public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { 
  this.jdbcTemplate = jdbcTemplate;  
 }  
 public Boolean saveMovieByPreparedStatement(final Movie1 e){   
     String query="insert into movies values(?,?,?)";   
     return jdbcTemplate.execute(query,new     
                         PreparedStatementCallback<Boolean>(){   
     @Override   
     public Boolean doInPreparedStatement(PreparedStatement ps)   
             throws SQLException, DataAccessException {   
         ps.setInt(1,e.getMid());   
         ps.setString(2,e.getTitle());   
         ps.setString(3,e.getActor());   
         return ps.execute();              
     }   
     });   
 }   
} 
 
Filename- appctx.xml 
 
<?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans" 
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
 xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">   
<property name="driverClassName" value="org.postgresql.Driver" />   
<property name="url" value="jdbc:postgresql://localhost:5434/postgres" />   
<property name="username" value="postgres" />   
<property name="password" value="ravita123" />   
</bean>   
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">   
<property name="dataSource" ref="ds"></property>   
</bean> 
<bean id="mymovie" class="MovieDAO1">   
<property name="jdbcTemplate" ref="jdbcTemplate"></property>   
</bean>  
</beans> 
 
Filename- MovieTest1.java 
import org.springframework.context.ApplicationContext;   
import org.springframework.context.support.ClassPathXmlApplicationContext;   
public class MovieTest1 { 
private static ApplicationContext appCon; 
public static void main(String[] args) { 
// TODO Auto-generated method stub 
appCon = new ClassPathXmlApplicationContext("appctx1.xml");  
MovieDAO1 m1=(MovieDAO1)appCon.getBean("mymovie");   
m1.saveMovieByPreparedStatement(new 
Movie1(3,"Inception","Cobb"));   
} 
} 
Output- 
Problem Statement 9.3 : Write a program in Spring JDBC to demonstrate 
ResultSetExtractor Interface. 
Solution : 
Filename- Movie2.java 
public class Movie2 { 
int mid; 
String title; 
String actor; 
public int getMid() { 
return mid; 
} 
public void setMid(int mid) { 
this.mid = mid; 
} 
public String getTitle() { 
return title; 
} 
public void setTitle(String title) { 
this.title = title; 
} 
public String getActor() { 
return actor; 
} 
public void setActor(String actor) { 
this.actor = actor; 
} 
public String toString(){   
return mid+" "+title+" "+actor;   
} 
} 
Filename- MovieDAO2.java 
import java.sql.ResultSet;   
import java.sql.SQLException;   
import java.util.ArrayList;   
import java.util.List;   
import org.springframework.dao.DataAccessException;   
import org.springframework.jdbc.core.JdbcTemplate;   
import org.springframework.jdbc.core.ResultSetExtractor;  
public class MovieDAO2 { 
JdbcTemplate jdbcTemplate; 
public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { 
this.jdbcTemplate = jdbcTemplate; 
}  
public List<Movie2> getAllMovie(){   
return jdbcTemplate.query("select * from movies",new  
 
ResultSetExtractor<List<Movie2>>(){   
      @Override   
       public List<Movie2> extractData(ResultSet rs) throws SQLException,   
              DataAccessException {   
         
          List<Movie2> list=new ArrayList<Movie2>();   
          while(rs.next()){   
           Movie2 e=new Movie2();   
           e.setMid(rs.getInt(1));   
           e.setTitle(rs.getString(2));   
           e.setActor(rs.getString(3));   
           list.add(e); 
          } 
          return list; 
          }   
      });   
    }  
} 
 
Filename- appctx2.java 
<?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans" 
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
 xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
 
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">   
<property name="driverClassName" value="org.postgresql.Driver" />   
<property name="url" value="jdbc:postgresql://localhost:5434/postgres" />   
<property name="username" value="postgres" />   
<property name="password" value="ravita123" />   
</bean>   
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">   
<property name="dataSource" ref="ds"></property>   
</bean>   
<bean id="mymovie" class="MovieDAO2">   
<property name="jdbcTemplate" ref="jdbcTemplate"></property>   
</bean>  
</beans> 
 
 Filename- MovieTest2.java 
import java.util.List;   
import org.springframework.context.ApplicationContext;   
import org.springframework.context.support.ClassPathXmlApplicationContext;   
public class MovieTest2 { 
 private static ApplicationContext appCon; 
 public static void main(String[] args) { 
  // TODO Auto-generated method stub 
  appCon = new ClassPathXmlApplicationContext("appctx2.xml");  
MovieDAO2 m1=(MovieDAO2)appCon.getBean("mymovie");  
List<Movie2> list=m1.getAllMovie();   
for(Movie2 e:list)   
System.out.println(e);   
}   
} 
OUTPUT- 
 
 
Problem Statement 9.4 : Write a program to demonstrate RowMapper interface to fetch the 
records from the database. 
Solution : 
Filename-Movie.java 
 
public class Movie3 { 
 int mid; 
 String title; 
 String actor; 
 public Movie3(int mid, String title, String actor) { 
  super(); 
  this.mid = mid; 
  this.title = title; 
  this.actor = actor; 
 } 
  
 public Movie3() { 
  super(); 
  // TODO Auto-generated constructor stub 
 } 
 public int getMid() { 
  return mid; 
 } 
 public void setMid(int mid) { 
  this.mid = mid; 
 } 
 public String getTitle() { 
  return title; 
 } 
 public void setTitle(String title) { 
  this.title = title; 
 } 
 public String getActor() { 
  return actor; 
 } 
 public void setActor(String actor) { 
  this.actor = actor; 
 } 
} 
 
Filename- MovieDAO3.java 
 
import java.sql.ResultSet; 
import java.sql.SQLException; 
import java.util.List; 
import org.springframework.jdbc.core.JdbcTemplate; 
import org.springframework.jdbc.core.RowMapper; 
 
public class MovieDAO3 { 
JdbcTemplate jdbcTemplate; 
public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { 
this.jdbcTemplate = jdbcTemplate; 
} 
public List<Movie2> getAllEmployeesRowMapper(){   
return jdbcTemplate.query("select * from movies",new 
RowMapper<Movie2>(){   
@Override   
public Movie2 mapRow(ResultSet rs, int rownumber) throws SQLException {   
Movie2 e=new Movie2();   
e.setMid(rs.getInt(1));   
e.setTitle(rs.getString(2));     
e.setActor(rs.getString(3));   
return e;   
}   
});    
}   
} 
Filename- appctx3.xml 
<?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">   
<property name="driverClassName" value="org.postgresql.Driver" />   
<property name="url" value="jdbc:postgresql://localhost:5434/postgres" />   
<property name="username" value="postgres" />   
<property name="password" value="ravita123" />   
</bean>   
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">   
<property name="dataSource" ref="ds"></property>   
</bean>   
<bean id="mymovie" class="MovieDAO3">   
<property name="jdbcTemplate" ref="jdbcTemplate"></property>   
</bean>  
</beans> 
Filename- MovieTest3.java 
import java.util.List;   
import org.springframework.context.ApplicationContext;   
import org.springframework.context.support.ClassPathXmlApplicationContext;   
public class MovieTest3 { 
private static ApplicationContext appCon; 
public static void main(String[] args) { 
// TODO Auto-generated method stub 
appCon = new ClassPathXmlApplicationContext("appctx3.xml");  
MovieDAO3 m1=(MovieDAO3)appCon.getBean("mymovie");  
List<Movie2> list=m1.getAllEmployeesRowMapper();   
for(Movie2 e:list)   
System.out.println(e); 
}} 
OUTPUT- 

 
Model which will map with the database(Table) . 
This Model and database connection Parameters will be passed to the Spring IoC 
 
Spring and JDBC : Spring legacy Project  
1. Create table emp1in postgreSQL 
 
 
 
2. Select New-> other->spring legacy project->simple java  
Give name to the project as springdatabase 
Create Model Employee with attributes same as in the table emp1 with 
constructors and getter setter methods. 
Right click on src -> new package as met.edu 
File : EMployee.java 
package met.edu; 
public class EMployee { 
int roll; 
String name; 
public EMployee() { 
super(); 
} 
public EMployee(int roll, String name) 
{ 
super(); 
this.roll = roll; 
this.name = name; 
} 
public int getRoll() { 
return roll; 
} 
public void setRoll(int roll) { 
this.roll = roll; 
} 
public String getName() { 
return name; 
} 
public void setName(String name) { 
this.name = name; 
} 
} 
Add spring library and jdbc jar files 
Right click on springdatabase-> buildpath->configurebuildpath 
Select Libraries and add external jar files and click apply  


Right click on src -> new appctx.xml 
File:appctx.xml 
<?xml version="1.0" encoding="UTF-8"?> 
<beans 
xmlns="http://www.springframework.org/sche
ma/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchem
a-instance" 
xsi:schemaLocation="http://www.springframe
work.org/schema/beans 
http://www.springframework.org/schema/bean
s/spring-beans.xsd"> 
<bean id="ds" 
class="org.springframework.jdbc.datasource.Driv
erManagerDataSource">   
<property name="driverClassName" 
value="org.postgresql.Driver" />   
<property name="url" 
value="jdbc:postgresql://localhost:5432/postgre
s" />   
<property name="username" value="postgres" />   
<property name="password" value="password" />   
</bean>   
<bean id="jdbcTemplate" 
class="org.springframework.jdbc.core.JdbcTempla
te">   
<property name="dataSource" ref="ds"> 
</property>  
</bean> 
<bean id="Emp1" class="edu.met.EMployeeDao"> 
<property name="jdbcTemplate" 
ref="jdbcTemplate"> 
</property>   
</bean>  
</beans> 
File: EMployeeDao.java 
import java.util.*; 
public class EMployeeDao { 
JdbcTemplate jdbcTemplate; 
public void 
setJdbcTemplate(JdbcTemplate jdbcTemplate) 
{ 
this.jdbcTemplate = jdbcTemplate; 
} 
public int saveEmp(EMployee e){   
String query="insert into emp1 
values("+e.getRoll()+",'"+e.getName()+"')"
;   
return jdbcTemplate.update(query);   
} 
public List<EMployee> findAll() { 
String sql = "SELECT * FROM emp1"; 
List<EMployee> customers = 
jdbcTemplate.query(sql,new 
EmpRowMapper()); 
return customers; 
} 
} 
File: EmpTest.java 
package edu.met; 
import org.springframework.context.ApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
import java.util.*; 
public class EmpTest 
{  
private static ApplicationContext appCon; 
public static void main(String[] args)  
{  
appCon = new ClassPathXmlApplicationContext("appctx.xml");  
EMployeeDao fac=(EMployeeDao)appCon.getBean("Emp1"); // link  
EMployee e1=new EMployee(4,"java jdbc"); 
System.out.println(fac.saveEmp(e1)); 
List<EMployee> lstemp=fac.findAll(); 
for(EMployee e2:lstemp) 
{ 
System.out.print(e2.getRoll()); 
System.out.println(e2.getName()); 
} 
} 
} 
File: EmpRowMapper.java 
package edu.met; 
import org.springframework.jdbc.core.RowMapper; 
import java.sql.ResultSet; 
import java.sql.SQLException; 
public class EmpRowMapper implements RowMapper<EMployee> { 
@Override 
public EMployee mapRow(ResultSet arg0, int arg1) throws SQLException 
{ 
EMployee e1=new EMployee(); 
e1.setRoll(arg0.getInt(1)); 
e1.setName(arg0.getString(2)); 
return e1; 
} 
} 
Right click on springdatabase and click on run java application 
Output 

 
Spring and AOP : Aspect Oriented Programming with Spring 
1. Select New-> other->aspectJProject 
 
 
  
Give name to the project as aspectprg 
 
 
 
 
Right click on src -> new package as met.edu 
File : BusinessService.java 
package met.edu; 
 
public class BusinessService { 
   
    public void runMyBusinessLogic(){ 
        System.out.println("************************************"); 
        System.out.println("Running business logic..."); 
        System.out.println("************************************"); 
    } 
      
    public void testThrowException() { 
        throw new NullPointerException(); 
    } 
} 
 
 
 
 
 
 
 
 
 
 
 
File:RunBeforeExecution.java 
package met.edu; 
 
 
import org.aspectj.lang.JoinPoint; 
import org.aspectj.lang.annotation.Aspect; 
import org.aspectj.lang.annotation.Before; 
  
@Aspect 
public class RunBeforeExecution { 
  
    @Before("execution(* met.edu.BusinessService.runMyBusinessLogic(..))") 
    public void before(JoinPoint joinPoint) throws Throwable { 
        System.out.println("Inside RunBeforeExecution.before() method..."); 
        System.out.println("inserted before : " + joinPoint.getSignature().getName()); 
    } 
} 
 
File: SpringDemo.java 
package met.edu; 
import java.util.*; 
import org.springframework.context.ConfigurableApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
public class SpringDemo { 
 static ConfigurableApplicationContext context; 
 public static void main(String[] args) { 
  String confFile = "applicationCtx.xml"; 
         
  context = new ClassPathXmlApplicationContext(confFile); 
        BusinessService busServ = (BusinessService) context.getBean("busService"); 
        busServ.runMyBusinessLogic(); 
        System.out.println("Press 'Enter' to terminate"); 
        new Scanner(System.in).nextLine(); 
        System.out.println("Exiting"); 
        System.exit(1); 
 } 
 
} 
 
 
 
 
 
 
 
 
 
 
 
 
Right click on src -> new applicationCtx.xml 
File: applicationCtx.xml 
<beans xmlns="http://www.springframework.org/schema/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:context="http://www.springframework.org/schema/context" 
xmlns:aop="http://www.springframework.org/schema/aop" 
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
http://www.springframework.org/schema/aop  
http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"> 
<aop:aspectj-autoproxy /> 
<bean id="busService" class="met.edu.BusinessService" /> 
<bean id="beforeAspectBean" class="met.edu.RunBeforeExecution" /> 
</beans> 
Right click on aspectprg-> buildpath->configurebuildpath 
Select Libraries and add external jar files and click apply  
Right click on aspectprg and click on run java application 
Output 
Aspect Oriented Programming 
1. Write a program to demonstrate Spring AOP – before advice.  
2. Write a program to demonstrate Spring AOP – after advice.  
3. Write a program to demonstrate Spring AOP – around advice.  
4. Write a program to demonstrate Spring AOP – after returning advice.  
5. Write a program to demonstrate Spring AOP – after throwing advice.  
6. Write a program to demonstrate Spring AOP – pointcuts. 
Steps to Create an AOP Project 
Step 1 :  Creating AspectJ Project. 
1.1 : Open Eclipse. Go To File > New > Other. 
1.2 : Search for ‘aspect’ and Select ‘AspectJ Project’. Then Click on Next. 
1.3 : Enter Project Name of your wish, and click on Finish. 
1.4 : If asked to create module-info.java file, select ‘Don’t Create’. 
1.5 : Finally if you are asked to Open Java Perspective, just choose NO.  
This creates your AspectJ project. 
Step 2 : Adding the Spring Libraries. 
2.1 : Right click on your Newly created AspectJ project, Choose Build Path > Configure Build 
Path. 
2.2 On Java Build Path wizard, Choose Classpathand then select Add External JARs. 
2.3 : Choose all the Spring Libraries you’ve downloaded, and click on OPEN. This will add all 
libraries to Classpath. 
2.4 Finally click on Apply & Close, now you are ready to work with Aspects in Spring. 
Problem Statement 1 : Write a program to demonstrate Spring AOP – before advice.  
Solution : 
beforeaop.java 
package bvimit.edu; 
import org.aspectj.lang.JoinPoint; 
import org.aspectj.lang.annotation.Aspect; 
import org.aspectj.lang.annotation.Before; 
import org.aspectj.lang.annotation.Pointcut; 
@Aspect 
public class beforeaop { 
@Pointcut("execution(int beforeoperation.*(..))") 
public void p(){} 
@Before("p()") 
public void myadvice(JoinPoint jp) 
{ 
System.out.println("before advice"); 
} 
} 
beforeoperation.java 
package bvimit.edu; 
public class beforeoperation { 
public void msg() {System.out.println("method 1");} 
public int m(){System.out.println("method 2 with return");return 2;} 
public int k(){System.out.println("method 3 with return");return 3;} 
} 
aopctx1.xml 
<?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
<bean id="opBean" class="bvimit.edu.beforeoperation"></bean> 
<bean id="trackMyBean" class="bvimit.edu.beforeaop"></bean> 
<bean 
class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"
></bean> 
</beans> 
beforetest.java 
package bvimit.edu; 
import org.springframework.context.ApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
public class beforetest { 
public static void main(String[] args) { 
ApplicationContext context = new 
ClassPathXmlApplicationContext("aopctx1.xml"); 
beforeoperation e = (beforeoperation) context.getBean("opBean"); 
System.out.println("calling m1......"); 
e.msg(); 
System.out.println("calling m2......"); 
e.m(); 
System.out.println("calling m3......"); 
e.k(); 
} 
} 
Output : 
Problem Statement 2 : Write a program to demonstrate Spring AOP – after advice.  
Solution : 
Afteraopdata.java 
package bvimit.edu; 
import org.aspectj.lang.JoinPoint; 
import org.aspectj.lang.annotation.After; 
import org.aspectj.lang.annotation.Aspect; 
import org.aspectj.lang.annotation.Pointcut; 
@Aspect 
public class afteraopdata { 
@Pointcut("execution(int afteroperation.*(..))") 
public void p(){} 
@After("p()") 
public void myadvice(JoinPoint jp) 
{ 
System.out.println("after advice"); 
} 
} 
afteroperation.java 
package bvimit.edu; 
publicclass afteroperation { 
publicvoid msg() {System.out.println("method 1");} 
publicint m(){System.out.println("method 2 with return");return 2;} 
publicint k(){System.out.println("method 3 with return");return 3;} 
} 
aopctx.xml 
<?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
<bean id="opBean" class="bvimit.edu.afteroperation"></bean> 
<bean id="trackMyBean" class="bvimit.edu.afteraopdata"></bean> 
<bean 
class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"
></bean> 
</beans> 
aftertest.java 
package bvimit.edu; 
import org.springframework.context.ApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
public class aftertest { 
public static void main(String[] args) { 
ApplicationContext context = new 
ClassPathXmlApplicationContext("aopctx.xml"); 
afteroperation e = (afteroperation) context.getBean("opBean"); 
System.out.println("calling m1......"); 
e.msg(); 
System.out.println("calling m2......"); 
e.m(); 
System.out.println("calling m3......"); 
e.k(); 
} 
} 
Output : 
Problem Statement 3 : Write a program to demonstrate Spring AOP – around advice.  
Solution : 
Bankaopdata.java 
package bvimit.edu; 
import org.aspectj.lang.ProceedingJoinPoint; 
import org.aspectj.lang.annotation.Around; 
import org.aspectj.lang.annotation.Aspect; 
import org.aspectj.lang.annotation.Pointcut; 
@Aspect 
public class Bankaopdata { 
@Pointcut("execution(* Bank.*(..))") 
public void a() {} 
@Around("a()") 
public Object myadvice(ProceedingJoinPoint p)throws Throwable 
{ 
System.out.println("Around concern Before calling actual method"); 
Object obj=p.proceed(); 
System.out.println("Around Concern After calling actual method"); 
return obj; 
} 
} 
Bank.java 
package bvimit.edu; 
publicclass Bank { 
publicvoid welcome() {System.out.println("welcome to bank");} 
publicint icici() {System.out.println("icici bank interest rate");return 7;} 
publicint pnb() {System.out.println("pnb bank interest rate");return 6;} 
} 
Bankaopdata.xml 
<?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
<bean id="opBean" class="bvimit.edu.Bank"></bean> 
<bean id="trackMyBean" class="bvimit.edu.Bankaopdata"></bean> 
<bean 
class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"
></bean> 
</beans> 
Banktest.java 
package bvimit.edu; 
import org.springframework.context.ApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
publicclass Banktest { 
privatestatic ApplicationContext context; 
publicstaticvoid main(String[] args) { 
context = new ClassPathXmlApplicationContext("Bankaopdata.xml"); 
Bank e =(Bank) context.getBean("opBean"); 
System.out.println("Calling welcome method..."); 
e.welcome(); 
System.out.println("Calling icici method..."); 
e.icici(); 
System.out.println("Calling pnb method..."); 
e.pnb(); 
} 
} 
Output : 

Problem Statement 4 : Write a program to demonstrate Spring AOP – after returning advice.  
Solution : 
Bankaopdata.java 
package bvimit.edu; 
import org.aspectj.lang.JoinPoint; 
importorg.aspectj.lang.ProceedingJoinPoint; 
import org.aspectj.lang.annotation.AfterReturning; 
importorg.aspectj.lang.annotation.Around; 
import org.aspectj.lang.annotation.Aspect; 
importorg.aspectj.lang.annotation.Pointcut; 
@Aspect 
publicclass Bankaopdata { 
@AfterReturning( 
pointcut ="execution(* Bank.*(..))", 
returning="result") 
publicvoid myadvice(JoinPoint jp,Object result) 
{ 
System.out.println("AfterReturning concern"); 
System.out.println("Result in advice" +result); 
} 
} 
Bank.java 
package bvimit.edu; 
publicclass Bank { 
publicvoid welcome() {System.out.println("welcome to bank");} 
publicint icici() {System.out.println("icici bank interest rate");return 7;} 
publicint pnb() {System.out.println("pnb bank interest rate");return 6;} 
} 
Bankaopdata.xml 
<?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
<bean id="opBean" class="bvimit.edu.Bank"></bean> 
<bean id="trackMyBean" class="bvimit.edu.Bankaopdata"></bean> 
<bean 
class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"
></bean> 
</beans> 
Banktest.java 
package bvimit.edu; 
import org.springframework.context.ApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
publicclass Banktest { 
privatestatic ApplicationContext context; 
publicstaticvoid main(String[] args) { 
context = new ClassPathXmlApplicationContext("Bankaopdata.xml"); 
Bank e =(Bank) context.getBean("opBean"); 
//System.out.println("Calling welcome method..."); 
e.welcome(); 
//System.out.println("Calling icici method..."); 
e.icici(); 
//System.out.println("Calling pnb method..."); 
e.pnb(); 
} 
} 
Output : 
Problem Statement 5 : Write a program to demonstrate Spring AOP – after throwing advice.  
Solution : 
 
Operationaop_at.java 
package bvimit.edu; 
import org.aspectj.lang.JoinPoint; 
import org.aspectj.lang.annotation.AfterThrowing; 
import org.aspectj.lang.annotation.Aspect; 
 
@Aspect 
publicclass Operationaop_at { 
@AfterThrowing( 
   pointcut = "execution(* Operation_at.*(..))", throwing = "error") 
 publicvoid myadvice(JoinPoint jp, Throwable error) 
 { 
  System.out.println("AfterThrowing concern"); 
  System.out.println("Exception is: "+error); 
  System.out.println("end of after throwing advice...."); 
 } 
 } 
 
Operation_at.java 
package bvimit.edu; 
publicclass Operation_at { 
 
 publicvoid validate(int att)throws Exception{ 
  if(att<75) { 
   thrownew ArithmeticException("Not eligible for exam"); 
  } 
  else { 
   System.out.println("Eligible for exam"); 
  } 
 } 
} 
 
 
 
 
 
 
 
 
 
 
validctx.xml 
<?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans" 
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
 xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
 
 
<bean id="opBean" class="bvimit.edu.Operation_at"></bean> 
 
<bean id="trackMyBean" class="bvimit.edu.Operationaop_at"></bean> 
 
<bean 
class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"
></bean></beans> 
 
TestValidation.java 
package bvimit.edu; 
import org.springframework.context.ApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
 
public class OperationTest_at { 
private static ApplicationContext context; 
  public static void main(String[] args) { 
ApplicationContext context = new ClassPathXmlApplicationContext("validctx.xml"); 
    Operation_at op = (Operation_at) context.getBean("opBean"); 
   System.out.println("calling validate...."); 
    try { 
     op.validate(85); 
    }catch(Exception e){System.out.println(e);} 
    
    System.out.println("calling validate again...."); 
    
    try { 
     op.validate(25); 
    }catch(Exception e){System.out.println(e);}  
    } 
   } 
 
 
 
 
 
 
 
 
Output : 
Problem Statements 6:Write a program to demonstrate Spring AOP –pointcuts. 
Solution: 
Operation_pc.java 
package bvimit.edu; 
publicclass Operation_pc { 
publicvoid msg() {System.out.println("method 1");} 
publicint m() {System.out.println("method 2 with return");return 2;} 
publicint k() {System.out.println("method 3 with return");return 3;} 
} 
Aopdata_pc.java 
package bvimit.edu; 
import org.aspectj.lang.JoinPoint; 
import org.aspectj.lang.annotation.After; 
import org.aspectj.lang.annotation.Pointcut; 
import org.aspectj.lang.annotation.Aspect; 
import org.aspectj.lang.annotation.Before; 
@Aspect 
public class Aopdata_pc { 
@Pointcut("execution(int Operation.*(..))") 
public void p(){} 
@After("p()") 
public void myadvice(JoinPoint jp) 
{ 
System.out.println("After advice"); 
} 
@Pointcut("execution(* Operation.*(..))") 
public void i(){} 
@Before("i()") 
public void myadvice1(JoinPoint jp) 
{ 
System.out.println("Before advice"); 
} 
} 
Test_pc.java 
package bvimit.edu; 
import org.springframework.context.ApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
public class Test_pc { 
public static void main(String[] args) { 
ApplicationContext context = new ClassPathXmlApplicationContext("aopctx_pc.xml"); 
Operation_pc e=(Operation_pc)context.getBean("opBean"); 
System.out.println("calling m1..."); 
e.msg(); 
System.out.println("calling m2..."); 
e.m(); 
System.out.println("calling m3..."); 
e.k(); 
} 
} 
aopctx_pc.xml 
<?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
<bean id="opBean" class="bvimit.edu.Operation_pc"></bean> 
<bean id="trackMyBean" class="bvimit.edu.Aopdata_pc"></bean> 
<bean 
class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"
></bean> 
</beans> 
Output: 